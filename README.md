# NodeJS Portainer App Template

## Описание

Это шаблон простого fullstack-приложения, состоящего из фронтенда на React и бэкенда на Express.js. Приложение собирается и разворачивается с помощью Docker Compose и предназначено для деплоя через Portainer на виртуальной машине. Фронтенд периодически (каждые 10 секунд) запрашивает текущее время сервера через REST API.

## Архитектура

- **Frontend**: React-приложение, собирается в статические файлы и обслуживается через Nginx.
- **Backend**: Express.js сервер, отдающий текущее время по эндпоинту `/api/getTimestamp`.
- **Nginx**: Используется как обратный прокси для маршрутизации запросов между фронтендом и бэкендом.
- **Docker Compose**: Управляет сборкой и запуском всех сервисов.

## Конфигурация Nginx

Файл [nginx/nginx.conf](nginx/nginx.conf) настраивает Nginx следующим образом:

- Все статические файлы фронтенда обслуживаются из `/usr/share/nginx/html`.
- Запросы к `/api` проксируются на backend-сервис (`http://backend:3001`).
- Для остальных маршрутов используется SPA-режим (`try_files $uri $uri/ /index.html`).
- Для статики настроено кэширование на 1 год.
- Отключены server_tokens для безопасности.

## Конфигурация Docker

- **[Dockerfile.client](Dockerfile.client)**: Собирает фронтенд, копирует сборку в Nginx.
- **[Dockerfile.server](Dockerfile.server)**: Собирает и запускает backend на Node.js 18.
- **[docker-compose.yml](docker-compose.yml)**: Описывает два сервиса:
  - `frontend` — React + Nginx, порт 80.
  - `backend` — Express.js, порт 3001, с healthcheck.
- Все зависимости устанавливаются через `npm ci` для воспроизводимости сборки.
- Переменные окружения и порты настраиваются для продакшн-режима.

## Оптимизация ресурсов

Приложение оптимизировано для работы на VDS с минимальными ресурсами:

### Минимальные требования
- CPU: 1 ядро
- RAM: 1 ГБ
- Диск: 5 ГБ свободного места

### Рекомендуемые требования
- CPU: 2 ядра
- RAM: 2 ГБ
- Диск: 10 ГБ свободного места

### Оптимизации

1. **Ограничение ресурсов в Docker Compose**:
   - Backend: 0.5 CPU, 512MB RAM
   - Frontend: 0.5 CPU, 512MB RAM
   - Nginx: 0.3 CPU, 256MB RAM
   - MySQL: 0.5 CPU, 512MB RAM

2. **Оптимизация Dockerfile**:
   - Использование alpine-версий базовых образов
   - Минимизация количества слоев в образах
   - Удаление ненужных зависимостей после сборки

3. **Оптимизация конфигурации MySQL**:
   - Уменьшен размер буфера InnoDB до 64MB
   - Отключен кэш запросов
   - Ограничено количество соединений
   - Оптимизированы размеры временных таблиц

## Деплой

1. Клонируйте репозиторий в Portainer.
2. Запустите стек через docker-compose.
3. Приложение будет доступно по публичному IP виртуальной машины.

## Безопасность

- API доступен только через фронтенд (Nginx не проксирует /api наружу напрямую).
- Кэширование и отключение server_tokens повышают безопасность и производительность.

## Режим моков

Для разработки и тестирования приложения без подключения к реальному API добавлен режим моков.

### Использование

Для запуска приложения в режиме моков используйте команду:

```bash
npm run start:mock
```

В этом режиме приложение будет использовать заранее подготовленные моковые данные вместо реальных API-запросов.

### Конфигурация

Режим моков настраивается через файл `.env.mock`, в котором установлена переменная:

```
REACT_APP_MOCK_MODE=true
```

## Команды для БД

### Просмотр содержимого тома:
```
# Посмотреть файлы в томе mysql_init
docker run --rm -v mysql_init:/data alpine ls -la /data

# Посмотреть содержимое файла
docker run --rm -v mysql_init:/data alpine cat /data/init.sql
```

### Резервное копирование:
```
# Бэкап тома в tar архив
docker run --rm -v mysql_init:/data -v $(pwd):/backup alpine \
  tar czf /backup/mysql_init_backup.tar.gz -C /data .

# Восстановление из бэкапа
docker run --rm -v mysql_init:/data -v $(pwd):/backup alpine \
  tar xzf /backup/mysql_init_backup.tar.gz -C /data
```

### Удаление и пересоздание:
```
# Остановить контейнеры
docker-compose down

# Удалить том (осторожно - данные будут потеряны!)
docker volume rm projectname_mysql_init

# Пересоздать и заполнить том
docker volume create projectname_mysql_init
./setup-volumes.sh

# Запустить снова
docker-compose up -d